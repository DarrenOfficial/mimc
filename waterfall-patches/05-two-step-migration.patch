diff --git a/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java b/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
index 886ab1c2..6557602e 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
@@ -47,6 +47,7 @@ import net.md_5.bungee.api.score.Score;
 import net.md_5.bungee.api.score.Scoreboard;
 import net.md_5.bungee.api.score.Team;
 import net.md_5.bungee.chat.ComponentSerializer;
+import net.md_5.bungee.mimc.PartitionManager;
 import net.md_5.bungee.netty.ChannelWrapper;
 import net.md_5.bungee.netty.PacketHandler;
 import net.md_5.bungee.protocol.DefinedPacket;
@@ -391,6 +392,33 @@ public class DownstreamBridge extends PacketHandler
     {
         PluginMessageEvent event = new PluginMessageEvent( server, con, pluginMessage.getTag(), pluginMessage.getData().clone() );
 
+        BungeeCord bungeeCord = ((BungeeCord)this.bungee);
+        bungeeCord.getLogger().warning(String.format("PluginMessage received %s", pluginMessage.getTag()) );
+
+        if ( pluginMessage.getTag().equals( "mimc:channel" ) )
+        {
+            PartitionManager partitionManager = ((BungeeCord)this.bungee).partitionManager;
+
+            bungeeCord.getLogger().warning("mimc:channel PluginMessage received");
+
+            DataInput di = pluginMessage.getStream();
+            String subChannel = di.readUTF();
+            bungeeCord.getLogger().warning( String.format("mimc:channel PluginMessage %s", subChannel) );
+
+            if (subChannel.equals("migration-prepared"))
+            {
+                String serverName = di.readUTF();
+                String playerName = di.readUTF();
+
+                partitionManager.completeMigration(playerName);
+            }
+            else if (subChannel.equals("migration-preparation-failed"))
+            {
+                String serverName = di.readUTF();
+                String playerName = di.readUTF();
+            }
+        }
+
         if ( bungee.getPluginManager().callEvent( event ).isCancelled() )
         {
             throw CancelSendSignal.INSTANCE;
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
index b379c8a9..f2bd128c 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
@@ -5,7 +5,10 @@ import com.mojang.brigadier.context.StringRange;
 import com.mojang.brigadier.suggestion.Suggestion;
 import com.mojang.brigadier.suggestion.Suggestions;
 import io.github.waterfallmc.waterfall.StringUtil;
+import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
+
+import java.io.DataInput;
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
@@ -22,6 +25,7 @@ import net.md_5.bungee.api.event.PluginMessageEvent;
 import net.md_5.bungee.api.event.SettingsChangedEvent;
 import net.md_5.bungee.api.event.TabCompleteEvent;
 import net.md_5.bungee.forge.ForgeConstants;
+import net.md_5.bungee.mimc.PartitionManager;
 import net.md_5.bungee.netty.ChannelWrapper;
 import net.md_5.bungee.netty.PacketHandler;
 import net.md_5.bungee.protocol.DefinedPacket;
diff --git a/proxy/src/main/java/net/md_5/bungee/mimc/MigrationRequest.java b/proxy/src/main/java/net/md_5/bungee/mimc/MigrationRequest.java
new file mode 100644
index 00000000..42f36490
--- /dev/null
+++ b/proxy/src/main/java/net/md_5/bungee/mimc/MigrationRequest.java
@@ -0,0 +1,26 @@
+package net.md_5.bungee.mimc;
+
+public class MigrationRequest {
+    public final Player player;
+    public final Partition target;
+
+    public MigrationRequest(Player player, Partition target) {
+        this.player = player;
+        this.target = target;
+    }
+
+    public int hashCode() {
+        int prime = 31;
+        int result = 13 * prime + this.player.hashCode();
+        result = result * prime + this.target.hashCode();
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == null) return false;
+        MigrationRequest otherRequest = (MigrationRequest)other;
+        return otherRequest.player == this.player
+                && otherRequest.target == this.target;
+    }
+}
diff --git a/proxy/src/main/java/net/md_5/bungee/mimc/Partition.java b/proxy/src/main/java/net/md_5/bungee/mimc/Partition.java
index ef26bdd4..9d1c814d 100644
--- a/proxy/src/main/java/net/md_5/bungee/mimc/Partition.java
+++ b/proxy/src/main/java/net/md_5/bungee/mimc/Partition.java
@@ -1,19 +1,13 @@
 package net.md_5.bungee.mimc;
 
-import com.google.common.io.ByteArrayDataOutput;
-import com.google.common.io.ByteStreams;
-import net.md_5.bungee.api.config.ServerInfo;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 
 public class Partition {
     public final long MERGE_RADIUS = 2 * 32 * 16; // 2 Region files radius
 
-    private String serverName;
-    private final List<Player> players = new ArrayList<>();
-    private final boolean isSpawnPartition;
+    public String serverName;
+    public final List<Player> players = new ArrayList<>();
+    public final boolean isSpawnPartition;
 
     public Partition(String serverName) { this(serverName, false); }
     public Partition(String serverName, boolean isSpawnPartition) {
@@ -37,32 +31,11 @@ public class Partition {
     public void add(Player player) {
         this.players.add(player);
     }
-
     public void remove(Player player) {
         this.players.remove(player);
     }
 
-    public void mergeInto(Partition other, Map<String, ServerInfo> servers) {
-        for (int i=other.players.size()-1;i>-1;i--) {
-            Player p = other.players.get(i);
-            p.migrateTo(this);
-            sendMigrationMessage(p, servers);
-        }
-    }
-    public void migrate(Player p, Map<String, ServerInfo> servers) {
-        p.migrateTo(this);
-        sendMigrationMessage(p, servers);
-    }
-
-    void sendMigrationMessage(Player p, Map<String, ServerInfo> servers) {
-        ByteArrayDataOutput out = ByteStreams.newDataOutput();
-        out.writeUTF( "Migrate" );
-        ServerInfo sourceServer = p.userCon.getServer().getInfo();
-
-        out.writeUTF( serverName );
-        out.writeUTF( p.name );
-
-        sourceServer.sendData("mimc", out.toByteArray());
-        p.userCon.connect(servers.get(serverName));
+    public int size() {
+        return this.players.size();
     }
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/mimc/PartitionManager.java b/proxy/src/main/java/net/md_5/bungee/mimc/PartitionManager.java
index c66aa676..53182a83 100644
--- a/proxy/src/main/java/net/md_5/bungee/mimc/PartitionManager.java
+++ b/proxy/src/main/java/net/md_5/bungee/mimc/PartitionManager.java
@@ -1,9 +1,11 @@
 package net.md_5.bungee.mimc;
 
+import com.google.common.io.ByteArrayDataOutput;
+import com.google.common.io.ByteStreams;
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.UserConnection;
 import net.md_5.bungee.api.config.ServerInfo;
-import net.md_5.bungee.api.connection.ProxiedPlayer;
+import net.md_5.bungee.mimc.util.CopyOnWriteSet;
 
 import java.util.*;
 
@@ -15,6 +17,7 @@ public class PartitionManager {
     private Map<String, ServerInfo> servers = new HashMap<>();
     private List<Partition> partitions = new ArrayList<>();
     private List<Player> players = new ArrayList<>();
+    private CopyOnWriteSet<MigrationRequest> migrationRequests = new CopyOnWriteSet<>();
 
     public PartitionManager(BungeeCord bungeeCord) {
         this.bungeeCord = bungeeCord;
@@ -37,6 +40,13 @@ public class PartitionManager {
         partitions.add(spawnPartition);
     }
 
+    public Player getPlayer(String playerName) {
+        for (int i = 0; i < players.size(); i++) {
+            Player p = players.get(i);
+            if (p.name.equals(playerName)) return p;
+        }
+        return null;
+    }
     public Player getPlayer(UUID uuid) {
         for (int i = 0; i < players.size(); i++) {
             Player p = players.get(i);
@@ -94,6 +104,45 @@ public class PartitionManager {
         return partition;
     }
 
+    public void requestMerge(Partition source, Partition target) {
+        for (int i=source.players.size()-1;i>-1;i--) {
+            Player p = source.players.get(i);
+            requestMigration(p, target);
+        }
+    }
+
+    public void requestMigration(Player p, Partition target) {
+        MigrationRequest request = new MigrationRequest(p, target);
+
+        // A previous request was sent out... waiting for response from that
+        // TODO: what if we never get a response?
+        if (this.migrationRequests.contains(request)) {
+            return;
+        }
+        this.migrationRequests.add(request);
+
+        sendMigrationMessage(p, target);
+    }
+
+    public boolean completeMigration(String playerName) {
+        bungeeCord.getLogger().warning( String.format("MIMC | completeMigration for %s", playerName) );
+
+        Iterator<MigrationRequest> iterator = this.migrationRequests.iterator();
+        while(iterator.hasNext()) {
+            MigrationRequest request = iterator.next();
+            Player p = request.player;
+            Partition target = request.target;
+
+            if (p.name.equals(playerName)) {
+                p.migrateTo(target);
+                p.userCon.connect(servers.get(target.serverName));
+                this.migrationRequests.remove(request);
+                return true;
+            }
+        }
+        return false;
+    }
+
     String suggestServerForNewPartition() {
         Map<String, Long> serverPartitionCounts = new HashMap<>();
 
@@ -142,15 +191,17 @@ public class PartitionManager {
                 target = previous;
             }
         } else if (partitionsInRange.size() > 1) {
-            target = partitionsInRange.get(0);
-            bungeeCord.getLogger().warning(String.format("MIMC | Adding player at %s to existing partition on node %s", p.location, target.getServerName()));
+            target = partitionsInRange.stream().max(Comparator.comparing(Partition::size)).get();
 
+            bungeeCord.getLogger().warning(String.format("MIMC | Adding player at %s to existing partition on node %s", p.location, target.getServerName()));
             bungeeCord.getLogger().warning(String.format("MIMC | Merging %d partitions that are in range", partitionsInRange.size()-1));
+
             for (int i = 1; i < partitionsInRange.size(); i++) {
                 Partition partitionToBeMerged = partitionsInRange.get(i);
-                target.mergeInto(partitionToBeMerged, this.servers);
+                requestMerge(partitionToBeMerged, target);
             }
             partitionsNotInRange.add(target);
+
             this.partitions = partitionsNotInRange;
         } else {
             target = partitionsInRange.get(0);
@@ -161,9 +212,19 @@ public class PartitionManager {
             } else if (target != previous) {
                 // The player moved away from his previous partition, and is now in range of a new partition
                 bungeeCord.getLogger().warning(String.format("MIMC | Migrating player at %s to other partition on node %s", p.location, target.getServerName()));
-                target.migrate(p, this.servers);
+                requestMigration(p, target);
             }
         }
         return target;
     }
+    void sendMigrationMessage(Player p, Partition target) {
+        ByteArrayDataOutput out = ByteStreams.newDataOutput();
+        out.writeUTF( "prepare-migration" );
+        ServerInfo sourceServer = p.userCon.getServer().getInfo();
+
+        out.writeUTF( target.serverName );
+        out.writeUTF( p.name );
+
+        sourceServer.sendData("mimc:channel", out.toByteArray());
+    }
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/mimc/util/CopyOnWriteSet.java b/proxy/src/main/java/net/md_5/bungee/mimc/util/CopyOnWriteSet.java
new file mode 100644
index 00000000..588fa87e
--- /dev/null
+++ b/proxy/src/main/java/net/md_5/bungee/mimc/util/CopyOnWriteSet.java
@@ -0,0 +1,56 @@
+package net.md_5.bungee.mimc.util;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
+
+public class CopyOnWriteSet<E> {
+
+    private final AtomicReference<Set<E>> ref;
+
+    public CopyOnWriteSet( ) {
+        ref = new AtomicReference<Set<E>>( new HashSet<E>() );
+    }
+    public CopyOnWriteSet( Collection<? extends E> c ) {
+        ref = new AtomicReference<Set<E>>( new HashSet<E>( c ) );
+    }
+
+    public boolean contains( Object o ) {
+        return ref.get().contains( o );
+    }
+
+    public Iterator<E> iterator() {
+        return ref.get().iterator();
+    }
+
+    public boolean add( E e ) {
+        while ( true ) {
+            Set<E> current = ref.get();
+            if ( current.contains( e ) ) {
+                return false;
+            }
+            Set<E> modified = new HashSet<E>( current );
+            modified.add( e );
+            if ( ref.compareAndSet( current, modified ) ) {
+                return true;
+            }
+        }
+    }
+
+    public boolean remove( Object o ) {
+        while ( true ) {
+            Set<E> current = ref.get();
+            if ( !current.contains( o ) ) {
+                return false;
+            }
+            Set<E> modified = new HashSet<E>( current );
+            modified.remove( o );
+            if ( ref.compareAndSet( current, modified ) ) {
+                return true;
+            }
+        }
+    }
+
+}
